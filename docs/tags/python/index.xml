<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on Q.G do Tux</title>
    <link>https://nic1611.github.io/blog/tags/python/</link>
    <description>Recent content in python on Q.G do Tux</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://nic1611.github.io/blog/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Criando um pipeline de Machine Learning utilizando o Scikit-learn</title>
      <link>https://nic1611.github.io/blog/post/pipeline_breast_cancer/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nic1611.github.io/blog/post/pipeline_breast_cancer/</guid>
      <description>Criando um pipeline de Machine Learning utilizando o Scikit-learn from sklearn.datasets import load_breast_cancer from sklearn.neighbors import KNeighborsClassifier from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.decomposition import PCA from sklearn.model_selection import GridSearchCV from sklearn.pipeline import Pipeline Vamos utilizar a base de dados breast cancer para essa demonstração cancer = load_breast_cancer() X = cancer.data Y = cancer.target Separamos as variaveis de dados e o nosso target entre teste e treino X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.</description>
    </item>
    
    <item>
      <title>Implementando um classificador NearestCentroid</title>
      <link>https://nic1611.github.io/blog/post/classificador-nearestcentroid/</link>
      <pubDate>Sun, 31 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nic1611.github.io/blog/post/classificador-nearestcentroid/</guid>
      <description>Implementando um classificador NearestCentroid Importação das Bibliotecas import numpy as np import matplotlib.pyplot as plt from math import sqrt Esses são os dados de treino que vamos utilizar Usando a biblioteca matplotlib, construimos um gráfico para melhor visualizar os dados
X_train = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]]) y_train = np.array([1, 1, 1, 2, 2, 2]) plt.scatter(X_train[y_train==1, 0], X_train[y_train==1, 1], c=&amp;#39;r&amp;#39;) plt.scatter(X_train[y_train==2, 0], X_train[y_train==2, 1], c=&amp;#39;g&amp;#39;) &amp;lt;matplotlib.</description>
    </item>
    
    <item>
      <title>classificação com KNN da base de dados breast_cancer</title>
      <link>https://nic1611.github.io/blog/post/cancer_de_mama/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nic1611.github.io/blog/post/cancer_de_mama/</guid>
      <description>0 - Carregando bibliotecas Nessa etapa, costuma-se dedicar a importação das bibliotecas que serão utilizadas no desenvolvimento do algoritmo de predição
from sklearn.datasets import load_breast_cancer from sklearn.neighbors import KNeighborsClassifier from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler import matplotlib.pylab as plt 1 - Abertura do dados Aqui, é feito o carregamento dos dados que serão utlizados para treino e teste do algoritmo
cancer = load_breast_cancer() cancer.DESCR 2 - Divisão em treinamento e teste Uma alternativa para separar os dados de treino e teste, é a utilização da função train_test_split presente na biblioteca sklearn.</description>
    </item>
    
    <item>
      <title>Introdução a visualização com Matplotlib</title>
      <link>https://nic1611.github.io/blog/post/introducao_ao_matplotlib/</link>
      <pubDate>Tue, 20 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nic1611.github.io/blog/post/introducao_ao_matplotlib/</guid>
      <description>Introdução O matplotlib é uma biblioteca para gerar gráficos ( plots ) em Python, inclusive em 3 dimensões. Abaixo um exemplo de como plotar um gráfico com matplotlib. Primeiramente importamos a interface baseada em estados ( pyplot ) do matplotlib. O padrão da comunidade é usar o alias plt :
from matplotlib import pyplot as plt import math import numpy as np Então, definimos uma sequencia de valores (em uma lista) a serem impressos.</description>
    </item>
    
    <item>
      <title>Normalização e Padronização</title>
      <link>https://nic1611.github.io/blog/post/normalizacao_e_padronizacao/</link>
      <pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nic1611.github.io/blog/post/normalizacao_e_padronizacao/</guid>
      <description>Normalização A normalização é boa para usar quando você sabe que a distribuição de seus dados não seguem uma distribuição Gaussiana. Isso pode ser útil em algoritmos que não assumem nenhuma distribuição de dados, como K-vizinhos mais próximos e redes neurais.
Uma das primeiras tarefas dentro do pré-processamento, é colocar seus dados na mesma escala. Muitos algoritmos de Machine Learning vão se beneficiar disso e produzir resultados melhores. Esta etapa também é chamada de normalização e significa colocar os dados em uma escala com range entre 0 e 1.</description>
    </item>
    
    <item>
      <title>Banco de Dados com Python</title>
      <link>https://nic1611.github.io/blog/post/banco_de_dados_com_python/</link>
      <pubDate>Sun, 20 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nic1611.github.io/blog/post/banco_de_dados_com_python/</guid>
      <description>Banco de Dados com Python O Python providencia um padrão, conhecido como Python DB-API, para acesso aos mais variados Bancos de Dados (BDs). Os principais elementos do Python DB-API são:
 Função connect : uma função usada para conectar a um BD e que retorna um objeto de conexão ; Objeto de conexão : representa uma conexão com um BD. Este objeto de conexão provê acesso a um cursor de objetos ; Cursor de objetos : é usado para executar comandos ou consultas SQL, após a execução de uma consultas haverá o resultado de uma execução no próprio cursor; Resultado de uma execução : São os resultados de uma execução de um comando SQL.</description>
    </item>
    
    <item>
      <title>Orientação a Objetos com Python</title>
      <link>https://nic1611.github.io/blog/post/orienta%C3%A7%C3%A3o_a_objetos_com_python/</link>
      <pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nic1611.github.io/blog/post/orienta%C3%A7%C3%A3o_a_objetos_com_python/</guid>
      <description>Orientação a Objetos Introdução A Orientação a Objetos (OO) é um paradigma de programação que estrutura uma aplicação de forma que os dados e as operações sobre estes dados são mantidas juntas em classes e acessadas via objetos. Outro tipo de paradigma de programação muito conhecido é o funcional, utilizado para criar programas na linguagem de programação R; muitas das features do paradigma funcional também estão disponível no Python.
Por exemplo, um aluno pode ser representado por uma classe Aluno que tem vários campos(atributos) como nome, código (id), data de nascimento, etc.</description>
    </item>
    
    <item>
      <title>Machine learning para bancos</title>
      <link>https://nic1611.github.io/blog/post/machine_learning_para_bancos/</link>
      <pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nic1611.github.io/blog/post/machine_learning_para_bancos/</guid>
      <description>Personalizando as Taxas de Acordo para cada Cliente Bancos e Cooperativas de Crédito Essas são 2 de uma infinidade de empresas que oferecem vários tipos de contas e fornecem empréstimos com base nos requisitos de seus clientes. Corretoras da Bolsa ofertam diversos produtos como investimentos em mercado e os mais variados fundos de investimento.
Existem muitos bancos em todo o mundo que estão aproveitando o aprendizado de máquina e a IA em sua rotina diária e obtendo benefícios com isso.</description>
    </item>
    
  </channel>
</rss>
