---
title: "Clustering usando R"
date: '2021-12-09'
featured_image: https://images.unsplash.com/photo-1489875347897-49f64b51c1f8?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1050&q=80
tags:
- R
- analise de dados
description: ''
---



<div id="clustering" class="section level1">
<h1>Clustering</h1>
<div id="introdução" class="section level2">
<h2>Introdução</h2>
<p>O objetivo do clustering é o de realizar o agrupamento de entidades / exemplos de um conjunto de dados (as linhas de uma matriz ou dataframe) com base na similaridade entre estes. Uma tarefa similar passa pelo agrupamento das colunas (variáveis).
Embora não se pretenda neste texto abordar em detalhe as variantes, as formulações e os algoritmos para realizar esta tarefa note-se que as abordagens para este problemas variam sobretudo nas métricas usadas com vista à definição de similaridade, nos algoritmos usados para realizar o agrupamento, na forma que assume a saída destes mesmos algoritmos e, finalmente, na forma de visualizar e interpretar os resultados.
Neste texto, abordaremos duas abordagens distintas, o clustering hierárquico e o clustering k-means, focando na forma como estas se podem implementar com a linguagem R.</p>
</div>
<div id="clustering-hierárquico" class="section level2">
<h2>Clustering hierárquico</h2>
<p>O clustering hierárquico tem como principal característica o tipo de resultados
que gera que está intimamente ligado com o processo usado na sua construção. Neste caso, o resultado final do processo é uma árvore binária que representa possíveis divisões dos dados em clusters. Assim, na raiz todos os dados estão agrupados num único cluster, e ao descer na árvore os clusters vão-se dividindo de forma binária, ou seja, em cada nó da árvore são criados dois clusters pela divisão de um único.
O método mais usado para construir estas árvores é designado por
aglomerativo, pois inicia-se com um cluster para cada exemplo, ou seja parte das folhas da árvore em direção à raiz, no processo de construção. Em cada iteração, vão-se juntando dois clusters e criando um único (criando nós na árvore) até se atingir o ponto em que todos os clusters estão unidos num único (raiz da árvore).
O processo é baseado numa matriz de distâncias onde estão guardadas as distâncias entre todos os pares de objetos; esta matriz é construída aplicando uma métrica de similaridade sobre as linhas da matriz inicial de dados. Esta pode ser, por exemplo, baseada em métricas clássicas de distância como a distância euclidiana ou a distância de Manhattan ou, em alternativa, métricas baseadas na correlação (e.g. Spearman ou Pearson.
Para obter uma matriz de distâncias em R, pode usar-se a função dist. Esta
recebe como argumento uma matriz ou um data frame com valores numéricos, retornando a matriz de distâncias. Por omissão, o método usado para o cálculo das distâncias é a distância euclidiana, mas podem ser escolhidas outras opções como a distância de Manhattan ou a distãncia de Minkowski, através da definição do argumento method.
O exemplo seguinte mostra como se pode calcular a matriz de distâncias para
um exemplo com pontos gerados de forma aleatória formando três clusters naturais. Note que o resultado é uma matriz triangular dado que as matrizes de distâncias são simétricas.</p>
<pre class="r"><code>x = rnorm(12,mean=rep(1:3,each=4),sd=0.2) 
y = rnorm(12,mean=rep(c(1,2,1),each=4),sd=0.2) 
dataFrame &lt;- data.frame(x=x,y=y) 
dist(dataFrame)</code></pre>
<pre><code>##            1         2         3         4         5         6         7
## 2  0.3061599                                                            
## 3  0.1469083 0.3201766                                                  
## 4  0.1383756 0.1687959 0.1770948                                        
## 5  1.2077874 1.5100614 1.2619053 1.3456734                              
## 6  1.0256136 1.3300363 1.0391864 1.1612794 0.3791958                    
## 7  1.3472882 1.6364254 1.4251974 1.4807370 0.2816261 0.6567212          
## 8  1.3294948 1.6338760 1.3409712 1.4651332 0.3955472 0.3038886 0.6497432
## 9  1.5014510 1.7431366 1.4264491 1.5999170 1.2074242 0.8740837 1.4849135
## 10 1.9053285 2.1530746 1.8353165 2.0075797 1.4350510 1.1640773 1.6928778
## 11 1.8884515 2.0434765 1.7696095 1.9431169 1.9358172 1.5757456 2.2169822
## 12 2.4396267 2.6461934 2.3438955 2.5209549 2.1211827 1.8320655 2.3812753
##            8         9        10        11
## 2                                         
## 3                                         
## 4                                         
## 5                                         
## 6                                         
## 7                                         
## 8                                         
## 9  0.8547389                              
## 10 1.0439456 0.4117764                    
## 11 1.6042672 0.7546840 0.8181655          
## 12 1.7319415 0.9835182 0.6886322 0.7432030</code></pre>
<p>Para executar o processo de clustering hierárquico usa-se a função hclust. Esta
recebe como argumento a matriz com as distâncias. Como argumento opcional (method), a função permite escolher a forma como se calculam distâncias entre clusters com mais do que um ponto nos passos intermédios do algoritmo. Os valores possíveis para esta opção incluem “complete” (valor por omissão, indica que a distância entre 2 clusters é a maior distância entre qualquer par de elementos dos 2 clusters), “single” (indica que a distância entre 2 clusters é a menor distância entre qualquer par de elementos dos 2 clusters) e “average” (indica que a distância entre 2 clusters é a média das distância entre todos os pares de elementos dos 2 clusters).
Veja-se um exemplo de aplicação da função hclust com os dados do exemplo
anterior:</p>
<pre class="r"><code>distxy = dist(dataFrame, method = &quot;euclidean&quot;) 
hc = hclust(distxy) 
plot(hc) </code></pre>
<p><img src="/blog/pt/post/clustering_usando_r/clustering_usando_R_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>Para ilustrar estes métodos com um exemplo usando um conjunto de dados de
maior dimensão, tome-se como ponto de partida os dados do conjunto de dados iris ja usados em capítulos anteriores. No exemplo seguinte, os dados são inicialmente standardizados para que a métrica de distância pese de forma uniforme as várias variáveis, podendo visualizar-se o efeito com um gráfico do tipo boxplot. Note-se que o atributo Species (posição 5) não é utilizado neste processo, sendo usados apenas os atributos numéricos.</p>
<pre class="r"><code>iris.sc = scale(iris[,1:4])
boxplot(iris[,1:4]) </code></pre>
<p><img src="/blog/pt/post/clustering_usando_r/clustering_usando_R_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<pre class="r"><code>boxplot(iris.sc)</code></pre>
<p><img src="/blog/pt/post/clustering_usando_r/clustering_usando_R_files/figure-html/unnamed-chunk-3-2.png" width="672" /></p>
<p>Em seguida, procede-se ao cálculo da matriz de distâncias usando distâncias
euclideanas e realiza-se o processo de clustering hierárquico usando a funçãoo hclust.</p>
<pre class="r"><code>dist.iris = dist(iris.sc, method = &quot;euclidean&quot;) 
hc.complete = hclust(dist.iris, method = &quot;complete&quot;) 
plot(hc.complete, cex = 0.4)</code></pre>
<p><img src="/blog/pt/post/clustering_usando_r/clustering_usando_R_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>No gráfico gerado pelo código anterior, note-se que o número de pontos torna o
resultado difícil de interpretar. Em muitos casos, faz sentido comparar a divisão dos dados em clusters com conhecimento próprio do problema. Neste caso, iremos usar o campo iris$Species como divisão natural dos dados (note-se que este campo não foi usado para realizar o clustering). O exemplo seguinte usa este campo para colocar as folhas da árvore e, assim, verificar os clusters gerados com os clusters naturais, usando dois valores distintos para o argumento method na função hclust.</p>
<pre class="r"><code>my.plot.hc = function(hclust, lab = 1:length(hclust$order),  
                      lab.col=rep(1, length(hclust$order)), hang = 0.1, ...) 
{ 
  y = rep(hclust$height, 2) 
  x = as.numeric(hclust$merge) 
  y = y[which(x&lt;0)] 
  x = x[which(x&lt;0)] 
  x = abs(x) 
  y = y[order(x)] 
  x = x[order(x)] 
  plot(hclust, labels = F, hang = hang, ...) 
  text(x = x, y = y[hclust$order]- (max(hclust$height) * hang),  
       labels = lab[hclust$order], col = lab.col[hclust$order], srt = 90,  
       adj = c(1,0.5), xpd = NA, ...) 
}

dist.iris = dist(iris.sc, method = &quot;euclidean&quot;) 
hc.complete = hclust(dist.iris, method = &quot;complete&quot;) 
my.plot.hc(hc.complete,lab.col=as.integer(iris$Species)+1, cex=0.4)</code></pre>
<p><img src="/blog/pt/post/clustering_usando_r/clustering_usando_R_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<pre class="r"><code>hc.average = hclust(dist.iris, method = &quot;average&quot;) 
my.plot.hc(hc.average,lab.col=as.integer(iris$Species)+1,cex=0.4)</code></pre>
<p><img src="/blog/pt/post/clustering_usando_r/clustering_usando_R_files/figure-html/unnamed-chunk-5-2.png" width="672" /></p>
<p>Uma representação gráfica dos dados relacionada com o clustering hierárquico
são os heatmaps, que podem ser construídos em R com a função heatmap. Esta permite representar os dados como uma imagem onde cada valor da matriz de dados é representado com uma célula cuja cor varia consoante o valor respetivo, num gradiente de cores que pode ser configurado. Os heatmaps tipicamente incluem as árvores criadas por clustering hierárquico quer ao nível das linhas, quer ao nível das colunas de dados. Note o exemplo seguinte:</p>
<pre class="r"><code>x1 &lt;- rnorm(12,mean=rep(1:3,each=4),sd=0.2) 
x2 &lt;- rnorm(12,mean=rep(1:3,each=4),sd=0.2) 
y1 &lt;- rnorm(12,mean=rep(c(1,2,1),each=4),sd=0.2) 
y2 &lt;- rnorm(12,mean=rep(c(1,2,1),each=4),sd=0.2) 
df2 = data.frame(x1, x2, y1, y2) 
heatmap(as.matrix(df2))</code></pre>
<p><img src="/blog/pt/post/clustering_usando_r/clustering_usando_R_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
</div>
<div id="clustering-k-means" class="section level2">
<h2>Clustering k-means</h2>
<p>O problema de clustering k-means constitui uma das possíveis formulações do clustering, onde o objetivo é o de minimizar a média do quadrado das distâncias de cada ponto ao centro do cluster a que pertence. Nesta formulação, o número de clusters é dado como parâmetro de entrada (designado por k). Dado que este problema apresenta uma significativa complexidade (dentro da classe dos problemas NP-completos), métodos heurísticos são tipicamente usados na resolução do problema.
A função kmeans permite resolver um problema de clustering k-means dado um
conjunto de dados e o valor de k (parâmetro centers).<br />
Veja um exemplo de seguida, usando os dados criados na secção anterior:</p>
<pre class="r"><code>resKmeans &lt;- kmeans(dataFrame, centers=3) 
resKmeans$cluster </code></pre>
<pre><code>##  [1] 1 1 1 1 2 2 2 2 3 3 3 3</code></pre>
<pre class="r"><code>plot(dataFrame$x,dataFrame$y, col=resKmeans$cluster, pch=19, cex=2) 
points(resKmeans$centers, col=1:3, pch=3, cex=3, lwd=3) </code></pre>
<p><img src="/blog/pt/post/clustering_usando_r/clustering_usando_R_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>Note-se que, em casos reais, dado que o método de otimização usado é heurístico
há a necessidade de se correr o algoritmo por diversas vezes, de forma a aumentar a qualidade da solução final encontrada. Este número de repetições pode ser controlado pelo parâmetro nstart.
De forma idêntica ao método anterior, ir-se-á demonstrar este método usando o
conjunto de dados iris.</p>
<pre class="r"><code>kmeans.iris = kmeans(iris[,1:4], centers = 3, nstart = 10000) 
table(kmeans.iris$cluster, iris$Species)</code></pre>
<pre><code>##    
##     setosa versicolor virginica
##   1      0          2        36
##   2      0         48        14
##   3     50          0         0</code></pre>
<p>Note-se que o segundo comando executado permite comparar o resultado da função kmeans com o agrupamento natural dos dados pelo campo Species. Esta comparação permite aferir da conformidade dos clusters gerados e dos clusters naturais.</p>
</div>
</div>
